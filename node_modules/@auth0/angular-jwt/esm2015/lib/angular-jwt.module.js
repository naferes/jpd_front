import * as ɵngcc0 from '@angular/core';
var JwtModule_1;
import { __decorate, __metadata, __param } from "tslib";
import { NgModule, Optional, SkipSelf, } from "@angular/core";
import { HTTP_INTERCEPTORS } from "@angular/common/http";
import { JwtInterceptor } from "./jwt.interceptor";
import { JWT_OPTIONS } from "./jwtoptions.token";
import { JwtHelperService } from "./jwthelper.service";
;
let JwtModule = JwtModule_1 = class JwtModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error("JwtModule is already loaded. It should only be imported in your application's main module.");
        }
    }
    static forRoot(options) {
        return {
            ngModule: JwtModule_1,
            providers: [
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: JwtInterceptor,
                    multi: true,
                },
                options.jwtOptionsProvider || {
                    provide: JWT_OPTIONS,
                    useValue: options.config,
                },
                JwtHelperService,
            ],
        };
    }
};
JwtModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: JwtModule });
JwtModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function JwtModule_Factory(t) { return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12)); } });
JwtModule.ctorParameters = () => [
    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
JwtModule = JwtModule_1 = __decorate([ __param(0, Optional()), __param(0, SkipSelf()),
    __metadata("design:paramtypes", [JwtModule])
], JwtModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JwtModule, [{
        type: NgModule
    }], function () { return [{ type: JwtModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();
export { JwtModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1qd3QubW9kdWxlLmpzIiwic291cmNlcyI6WyJuZzovQGF1dGgwL2FuZ3VsYXItand0L2xpYi9hbmd1bGFyLWp3dC5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsT0FBTyxFQUNMLFFBQVEsRUFFUixRQUFRLEVBQ1IsUUFBUSxHQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBZSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDakQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFZdEQsQ0FBQztBQVFGLElBQWEsU0FBUyxpQkFBdEIsTUFBYSxTQUFTO0FBQ3RCLElBQUUsWUFBb0MsWUFBdUI7QUFDN0QsUUFBSSxJQUFJLFlBQVksRUFBRTtBQUN0QixZQUFNLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEZBQTRGLENBQzdGLENBQUM7QUFDUixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQXlCO0FBQUksUUFDMUMsT0FBTztBQUNYLFlBQU0sUUFBUSxFQUFFLFdBQVM7QUFDekIsWUFBTSxTQUFTLEVBQUU7QUFDakIsZ0JBQVE7QUFDUixvQkFBVSxPQUFPLEVBQUUsaUJBQWlCO0FBQ3BDLG9CQUFVLFFBQVEsRUFBRSxjQUFjO0FBQ2xDLG9CQUFVLEtBQUssRUFBRSxJQUFJO0FBQ3JCLGlCQUFTO0FBQ1QsZ0JBQVEsT0FBTyxDQUFDLGtCQUFrQixJQUFJO0FBQ3RDLG9CQUFVLE9BQU8sRUFBRSxXQUFXO0FBQzlCLG9CQUFVLFFBQVEsRUFBRSxPQUFPLENBQUMsTUFBTTtBQUNsQyxpQkFBUztBQUNULGdCQUFRLGdCQUFnQjtBQUN4QixhQUFPO0FBQ1AsU0FBSyxDQUFDO0FBQ04sSUFBRSxDQUFDO0FBQ0gsQ0FBQzs7c0pBQUE7QUFDRDtBQUFtQyxZQXpCaUIsU0FBUyx1QkFBOUMsUUFBUSxZQUFJLFFBQVE7QUFBTTtBQUQ1QixTQUFTLGtDQURyQixRQUFRLEVBQUUsZkFDUCxDQUNXLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLFFBQVEsRUFBRSxDQUFBO0FBQUUscUNBQWEsU0FBUztBQUFHLEdBRG5ELFNBQVMsQ0F5QnJCOzs7Ozs7O2tDQUNEO0FBQUMsU0ExQlksU0FBUztBQUNyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIE5nTW9kdWxlLFxuICBNb2R1bGVXaXRoUHJvdmlkZXJzLFxuICBPcHRpb25hbCxcbiAgU2tpcFNlbGYsXG4gIFByb3ZpZGVyLFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSHR0cFJlcXVlc3QsIEhUVFBfSU5URVJDRVBUT1JTIH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vbi9odHRwXCI7XG5pbXBvcnQgeyBKd3RJbnRlcmNlcHRvciB9IGZyb20gXCIuL2p3dC5pbnRlcmNlcHRvclwiO1xuaW1wb3J0IHsgSldUX09QVElPTlMgfSBmcm9tIFwiLi9qd3RvcHRpb25zLnRva2VuXCI7XG5pbXBvcnQgeyBKd3RIZWxwZXJTZXJ2aWNlIH0gZnJvbSBcIi4vand0aGVscGVyLnNlcnZpY2VcIjtcblxuZXhwb3J0IGludGVyZmFjZSBKd3RDb25maWcge1xuICB0b2tlbkdldHRlcj86IChcbiAgICByZXF1ZXN0PzogSHR0cFJlcXVlc3Q8YW55PlxuICApID0+IHN0cmluZyB8IG51bGwgfCBQcm9taXNlPHN0cmluZyB8IG51bGw+O1xuICBoZWFkZXJOYW1lPzogc3RyaW5nO1xuICBhdXRoU2NoZW1lPzogc3RyaW5nIHwgKChyZXF1ZXN0PzogSHR0cFJlcXVlc3Q8YW55PikgPT4gc3RyaW5nKTtcbiAgd2hpdGVsaXN0ZWREb21haW5zPzogQXJyYXk8c3RyaW5nIHwgUmVnRXhwPjtcbiAgYmxhY2tsaXN0ZWRSb3V0ZXM/OiBBcnJheTxzdHJpbmcgfCBSZWdFeHA+O1xuICB0aHJvd05vVG9rZW5FcnJvcj86IGJvb2xlYW47XG4gIHNraXBXaGVuRXhwaXJlZD86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEp3dE1vZHVsZU9wdGlvbnMge1xuICBqd3RPcHRpb25zUHJvdmlkZXI/OiBQcm92aWRlcjtcbiAgY29uZmlnPzogSnd0Q29uZmlnO1xufVxuXG5ATmdNb2R1bGUoKVxuZXhwb3J0IGNsYXNzIEp3dE1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIHBhcmVudE1vZHVsZTogSnd0TW9kdWxlKSB7XG4gICAgaWYgKHBhcmVudE1vZHVsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkp3dE1vZHVsZSBpcyBhbHJlYWR5IGxvYWRlZC4gSXQgc2hvdWxkIG9ubHkgYmUgaW1wb3J0ZWQgaW4geW91ciBhcHBsaWNhdGlvbidzIG1haW4gbW9kdWxlLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZm9yUm9vdChvcHRpb25zOiBKd3RNb2R1bGVPcHRpb25zKTogTW9kdWxlV2l0aFByb3ZpZGVyczxKd3RNb2R1bGU+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IEp3dE1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsXG4gICAgICAgICAgdXNlQ2xhc3M6IEp3dEludGVyY2VwdG9yLFxuICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLmp3dE9wdGlvbnNQcm92aWRlciB8fCB7XG4gICAgICAgICAgcHJvdmlkZTogSldUX09QVElPTlMsXG4gICAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnMuY29uZmlnLFxuICAgICAgICB9LFxuICAgICAgICBKd3RIZWxwZXJTZXJ2aWNlLFxuICAgICAgXSxcbiAgICB9O1xuICB9XG59XG4iXX0=